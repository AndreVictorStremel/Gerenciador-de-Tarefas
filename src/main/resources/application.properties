
# 1. CONFIGURAÇÕES DO SERVIDOR WEB

# [cite_start]Define a porta onde a aplicação vai rodar, conforme solicitado. [cite: 39]
server.port=8081

# Defina o caminho de contexto base para todos os endpoints da API.
# Note: o controller não define mais @RequestMapping de classe, usamos o contexto aqui.

# server.servlet.context-path=/tarefas-api = comentario para nao entrar em conflito com o controller


# 2. CONFIGURAÇÕES DE CONEXÃO COM O BANCO (DATASOURCE)

# [cite_start]A URL de conexão JDBC para o PostgreSQL. [cite: 14]
# - jdbc:postgresql:// -> Protocolo para conectar com o PostgreSQL.
# - localhost:5432/ -> Endereço do seu banco (localhost) e a porta padrão (5432).
# - tarefasdb -> O nome do banco de dados que criamos na Parte 1.
## Configuração para PostgreSQL (prod/local com Postgres em localhost)
spring.datasource.url=jdbc:postgresql://localhost:5432/tarefasdb

# O nome de usuário para acessar o banco de dados. O padrão é 'postgres'.
spring.datasource.username=postgres

# A senha do usuário. 
spring.datasource.password=Andre@23237


# 3. CONFIGURAÇÕES DO HIBERNATE (JPA)

# Esta é a configuração mais importante para o desenvolvimento.
# [cite_start]'update': O Hibernate (que é o ORM usado pelo Spring Data JPA [cite: 4, 17]) irá comparar sua entidade Java (@Entity Tarefa)
# com o banco de dados. Se a tabela 'tarefa' não existir, ele a cria. Se você adicionar uma nova
# coluna na sua classe Java, ele executa um 'ALTER TABLE' para adicioná-la no banco.
spring.jpa.hibernate.ddl-auto=update

# Faz com que o Spring mostre no console de execução todas as queries SQL que o Hibernate
# está gerando e executando no banco. É excelente para depuração.
spring.jpa.show-sql=true

# Formata o SQL mostrado no console para que ele fique mais legível e organizado.
spring.jpa.properties.hibernate.format_sql=true